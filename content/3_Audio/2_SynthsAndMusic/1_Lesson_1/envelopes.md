---
title: Envelopes, Filters, LFO, & Noise
weight: 2
---

## Envelopes 

Without parameters, sounds generated by a synthesizer would run indefinitely until they were shut off or the hardware malfunctioned. By using a sound envelop, we can further customize our synthetic sounds to meet our desired timbres. The envelope of a sound is a series of volumes applied to the sound in order to give it a natural lifespan from the onset to the release. You can think of these as a literal envelope that you are having to shove the sound inside of, and you need to adjust the sound's volume in order to make it fit. Every envelope contains four distinct parts: the attack, decay, sustain, and release; also called the ADSR.


### ADSR

- Attack time is the time taken for initial run-up of level from nil to peak, beginning when the key is first pressed.
- Decay time is the time taken for the subsequent run down from the attack level to the designated sustain level.
- Sustain level is the level during the main sequence of the sound's duration, until the key is released.
- Release time is the time taken for the level to decay from the sustain level to zero after the key is released.

There is a wonder [Tone example](https://tonejs.github.io/examples/envelope.html) that shows how you can alter the different parameters to adjust the characteristics of the sounds. experiment with this to see what having various combinations will result in. How would you get a short percussive sound? a sound that fades in and out? a sound with a long, gradual decay.

To set the ADSR, you must first open up the `.envelope` properties of the `Tone.Synth()`. The example below shows how to build a simple synthesizer with the envelope features. 

{{% codepen 600 VwvbLQo %}}

We can update these four values in real time if we want. The example below uses sliders to adjust the ADSR of the synthesized sound similarly to the sampler assignment.

{{% codepen 600 yLYzQLa %}}

You can also set triggers to adjust the parameters in a fashion similar to below:

```

if(condition to change attack === true){
  simpSynth.envelope.attack = 1;
} else {
  simpSynth.envelope.attack = 0.05;
  }

```

This is an effective way to create different variations on the same synthesized sound. An idea that will come in handy during the next assignment.
 
---

## Filters

- A [filter](https://tonejs.github.io/docs/r11/Filter) modifies a source sound by either amplifying or reducing certain frequency ranges of that sound; causing a change in the 'brightness' of that sound. They act similarly to a coffee filter, letting some materials through the fine mesh, while blocking others.

### Parameters of Tone.Filter()

* cutoff frequency: frequency where the filter begins to take effect.
* type: specific frequencies the filter alters. Filter types can include:
  * lowpass: reduces frequencies above a cutoff point, letting the low frequencies pass through.
  * highpass: reduces frequencies below a cutoff point, letting the high frequencies pass through.
  * bandpass: reduces frequencies above and below a cutoff point, letting only a small band of frequencies pass through.
  * lowshelf: boosts or reduces only the low frequencies.
  * highshelf: boosts or reduces only the high frequencies. 
  * notch: the opposite of a bandpass filter. it allows all frequencies except those around a cutoff to pass through.
  * allpass: allows all frequencies to pass through.
  * peaking: boosts or removes frequencies around a center frequency to better isolate that frequency.
* rolloff: how much the sound volume is reduced by the filter in decibels.
* Q: how quickly the filter is applied to its frequency range

You can utilize a filter by connecting your sound source to the `Tone.Filter()` object before sending the signal to the master speakers.

```
filt = new Tone.Filter({
type : lowpass ,
frequency : 350 ,
rolloff : -12 ,
Q : 1 ,
}).toMaster();
```
Try changing the filter type and cutoff frequency in the example below to see how the different filters change the noise being output.

---

## LFO

An LFO, or Low Frequency Oscillator functions identically to the oscillators in Tone.Synth(), but with one major difference: LFOs move much slower. Most LFOs move back and forth between 0.5-10 times per second. This means that we do not hear a pitch from these oscillators. Generally they are used to automate and alter various parameters of other parts of a synthesizer; any parameter of a synthesizer that can be adjusted can potentially be altered through use of an LFO. One signal with another like this is called modulation.

Here we have an example that is using the `Tone.LFO)()` object to modulate filters applied to noise and the pitch of an oscillator. 

{{% codepen 600 JxxbMy %}}

Try using this [starter](https://codepen.io/lsuddem/pen/QYYGmL) code to creade your own LFO modulations. 

---

## Noise

Noise is a kind of generate sound with no definite pitch, and that occurs across the entire frequency spectrum. It Is achieved by generating random frequencies in various proportions at once. 


- [Tone.Noise](https://tonejs.github.io/docs/r11/Noise) produces different colors of noise. 
  * white: all frequencies are present in equal proportions.
  * pink: Higher frequencies are less present than lower frequencies. The rolloff is 3dB per octave. 
  * brown: similar to pink noise, but with a steeper rolloff of 6dB per octave
- Each has a different sound, covers a different frequency range, and is used for different purposes. 

There are other colors of noise that Tone doesn't implement that are good to know about.  You can check out information about those types of noise at [this link](https://en.wikipedia.org/wiki/Colors_of_noise)

  
Try changing the noise type in the example below to see their differences in timbre and frequency.

{{% codepen 600 VdxRxz %}}

---
